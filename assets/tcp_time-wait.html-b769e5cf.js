import{_ as e}from"./tcp四次挥手-81bd10ac.js";import{_ as i,p as t,q as c,a1 as o}from"./framework-5866ffd3.js";const d="/assets/TIME_WAIT_ACK丢失-27c36a95.png",a="/assets/TIME_WAIT_RST-e17b4a5f.png",l="/assets/TIME_WAIT_服务器延时数据包-67b67704.png",s={},_=o(`<h1 id="tcptimewait" tabindex="-1"><a class="header-anchor" href="#tcptimewait" aria-hidden="true">#</a> tcpTIMEWAIT</h1><ul><li><p>回顾 TCP 四次挥手：正常情况下服务端收到了 <code>ACK</code> 消息并关闭当前 TCP 连接，客户端等待</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code> msl 查看
 cat /proc/sys/net/ipv4/tcp_fin_timeout
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>2msl(Maximum Segment Lifetime) 进入 CLOSED。<img src="`+e+'" alt="tcp四次挥手"></p></li></ul><p>从上述过程中，我们会发现 <code>TIME_WAIT</code> 仅在主动断开连接的一方出现，被动断开连接的一方会直接进入 <code>CLOSED</code> 状态，进入 <code>TIME_WAIT</code> 的客户端需要等待 2 MSL 才可以真正关闭连接。</p><h3 id="一、没有-time-wait、或-time-wait-时间过短的问题" tabindex="-1"><a class="header-anchor" href="#一、没有-time-wait、或-time-wait-时间过短的问题" aria-hidden="true">#</a> 一、没有 TIME_WAIT、或 TIME_WAIT 时间过短的问题</h3><ul><li><p>防止延迟的数据段被其他使用相同源地址、源端口、目的地址以及目的端口的 TCP 连接收到；</p><ul><li><p>场景1：由于丢包（客户端发送的 <code>ACK</code> 丢失），服务端没有收到 <code>ACK</code> 消息，服务器重新发送 <code>FIN</code> 关闭连接并等待新的 <code>ACK</code> 消息。如果没有 TIME_WAIT、或 TIME_WAIT 时间过短客户端无法收到重传的 <code>FIN</code> 包导致四次挥手服务优雅的完成。</p><p><img src="'+d+'" alt="TIME_WAIT_ACK丢失"></p></li><li><p>场景2：假设刚好客户端以相同端口发送 <code>SYN</code>，那么服务器端就会返回 <code>RST</code>。</p><p><img src="'+a+'" alt="TIME_WAIT_RST"></p></li><li><p>场景3：由于 TIME_WAIT 过短，客户端用之前的端口新建 session。客户端收到了上个会话服务端延时的数据包。</p><p><img src="'+l+'" alt="TIME_WAIT_服务器延时数据包"></p></li></ul></li></ul><h3 id="三、解决-time-wait-过多新会话无法建立" tabindex="-1"><a class="header-anchor" href="#三、解决-time-wait-过多新会话无法建立" aria-hidden="true">#</a> 三、解决 TIME_WAIT 过多新会话无法建立</h3><ol><li>使用 <code>SO_LINGER</code> 选项并设置暂存时间 <code>l_linger</code> 为 0，在这时如果我们关闭 TCP 连接，内核就会直接丢弃缓冲区中的全部数据并向服务端发送 <code>RST</code> 消息直接终止当前的连接。</li><li>使用 <code>net.ipv4.tcp_tw_reuse</code> 选项，通过 TCP 的时间戳选项允许内核重用处于 <code>TIME_WAIT</code> 状态的 TCP 连接。</li><li>修改 <code>net.ipv4.ip_local_port_range</code> 选项中的可用端口范围，增加可同时存在的 TCP 连接数上限</li><li>TCP 配置项 <code>net.ipv4.tcp_tw_recycle</code> 已经在 Linux 4.12 中移除，所以我们不能再通过该配置解决 <code>TIME_WAIT</code> 设计带来的问题。</li></ol>',7),n=[_];function p(r,T){return t(),c("div",null,n)}const u=i(s,[["render",p],["__file","tcp_time-wait.html.vue"]]);export{u as default};
