import{_ as p,p as t,q as s,a1 as e}from"./framework-5866ffd3.js";const o={},r=e('<h1 id="_4-12-tcp-连接-一端断电和进程崩溃有什么区别" tabindex="-1"><a class="header-anchor" href="#_4-12-tcp-连接-一端断电和进程崩溃有什么区别" aria-hidden="true">#</a> 4.12 TCP 连接，一端断电和进程崩溃有什么区别？</h1><p>有位读者找我说，他在面试腾讯的时候，遇到了这么个问题：</p><p><img src="https://img-blog.csdnimg.cn/2021061513401120.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0ODI3Njc0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>这个属于 <strong>TCP 异常断开连接</strong>的场景，这部分内容在我的「图解网络」还没有详细介绍过，这次就乘着这次机会补一补。</p><p><img src="https://img-blog.csdnimg.cn/20210615134020994.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0ODI3Njc0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>好了，继续今天的主题。</p><p>这个问题有几个关键词：</p><ul><li>没有开启 keepalive；</li><li>一直没有数据交互；</li><li>进程崩溃；</li><li>主机崩溃；</li></ul><p>我们先来认识认识什么是 TCP keepalive 呢？</p><p>这东西其实就是 <strong>TCP 的保活机制</strong>，它的工作原理我之前的文章写过，这里就直接贴下以前的内容。</p><p><img src="https://img-blog.csdnimg.cn/20210615134028909.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0ODI3Njc0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>如果两端的 TCP 连接一直没有数据交互，达到了触发 TCP 保活机制的条件，那么内核里的 TCP 协议栈就会发送探测报文。</p><ul><li>如果对端程序是正常工作的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 <strong>TCP 保活时间会被重置</strong>，等待下一个 TCP 保活时间的到来。</li><li>如果对端主机崩溃，或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，<strong>TCP 会报告该 TCP 连接已经死亡</strong>。</li></ul><p>所以，TCP 保活机制可以在双方没有数据交互的情况，通过探测报文，来确定对方的 TCP 连接是否存活。</p><p><img src="https://img-blog.csdnimg.cn/20210615134036676.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0ODI3Njc0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>注意，应用程序若想使用 TCP 保活机制需要通过 socket 接口设置 <code>SO_KEEPALIVE</code> 选项才能够生效，如果没有设置，那么就无法使用 TCP 保活机制。</p><p>知道了 TCP keepalive 作用，我们再回过头看题目中的「主机崩溃」这种情况。</p><blockquote><p>在没有开启 TCP keepalive，且双方一直没有数据交互的情况下，如果客户端的「主机崩溃」了，会发生什么。</p></blockquote><p>客户端主机崩溃了，服务端是<strong>无法感知到的</strong>，在加上服务端没有开启 TCP keepalive，又没有数据交互的情况下，<strong>服务端的 TCP 连接将会一直处于 ESTABLISHED 连接状态</strong>，直到服务端重启进程。</p><p>所以，我们可以得知一个点，在没有使用 TCP 保活机制且双方不传输数据的情况下，一方的 TCP 连接处在 ESTABLISHED 状态，并不代表另一方的连接还一定正常。</p><blockquote><p>那题目中的「进程崩溃」的情况呢？</p></blockquote><p>我自己做了实验，使用 kill -9 来模拟进程崩溃的情况，发现<strong>在 kill 掉进程后，服务端会发送 FIN 报文，与客户端进行四次挥手</strong>。</p><p>所以，即使没有开启 TCP keepalive，且双方也没有数据交互的情况下，如果其中一方的进程发生了崩溃，这个过程操作系统是可以感知的到的，于是就会发送 FIN 报文给对方，然后与对方进行 TCP 四次挥手。</p><p><img src="https://img-blog.csdnimg.cn/2021061513405211.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0ODI3Njc0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><hr><p>以上就是对这个面试题的回答，接下来我们看看在「<strong>有数据传输</strong>」的场景下的一些异常情况：</p><ul><li>第一种，客户端主机宕机，又迅速重启，会发生什么？</li><li>第二种，客户端主机宕机，一直没有重启，会发生什么？</li></ul><h5 id="客户端主机宕机-又迅速重启" tabindex="-1"><a class="header-anchor" href="#客户端主机宕机-又迅速重启" aria-hidden="true">#</a> 客户端主机宕机，又迅速重启</h5><p>在客户端主机宕机后，服务端向客户端发送的报文会得不到任何的响应，在一定时长后，服务端就会触发<strong>超时重传</strong>机制，重传未得到响应的报文。</p><p>服务端重传报文的过程中，客户端主机重启完成后，客户端的内核就会接收重传的报文，然后根据报文的信息传递给对应的进程：</p><ul><li>如果客户端主机上<strong>没有</strong>进程监听该 TCP 报文的目标端口号，那么客户端内核就会**回复 RST 报文，重置该 TCP 连接*；</li><li>如果客户端主机上<strong>有</strong>进程监听该 TCP 报文的目标端口号，由于客户端主机重启后，之前的 TCP 连接的数据结构已经丢失了，客户端内核里协议栈会发现找不到该 TCP 连接的 socket 结构体，于是就会<strong>回复 RST 报文，重置该 TCP 连接</strong>。</li></ul><p>所以，只要有一方重启完成后，收到之前 TCP 连接的报文，都会回复 RST 报文，以断开连接。</p><h5 id="客户端主机宕机-一直没有重启" tabindex="-1"><a class="header-anchor" href="#客户端主机宕机-一直没有重启" aria-hidden="true">#</a> 客户端主机宕机，一直没有重启</h5><p>这种情况，服务端超时重传报文的次数达到一定阈值后，内核就会判定出该 TCP 有问题，然后通过 Socket 接口告诉应用程序该 TCP 连接出问题了，一般就是 ETIMEOUT 状态码。</p><p>那具体重传几次呢？</p><p>在 Linux 系统中，提供一个叫 tcp_retries2 配置项，默认值是 15，如下图：</p><p><img src="https://img-blog.csdnimg.cn/20210615134059647.png" alt="在这里插入图片描述"></p><p>这个内核参数是控制，在 TCP 连接建立的情况下，超时重传的最大次数。</p><p>不过 tcp_retries2 设置了 15 次，并不代表 TCP 超时重传了 15 次才会通知应用程序终止该 TCP 连接，内核还会基于「最大超时时间」来判定。</p><p>每一轮的超时时间都是<strong>倍数增长</strong>的，比如第一次触发超时重传是在 2s 后，第二次则是在 4s 后，第三次则是 8s 后，以此类推。</p><p><img src="https://img-blog.csdnimg.cn/2021061513410645.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0ODI3Njc0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>内核会根据 tcp_retries2 设置的值，计算出一个最大超时时间。</p><p><img src="https://img-blog.csdnimg.cn/20210615134110763.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0ODI3Njc0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>在重传报文且一直没有收到对方响应的情况时，先达到「最大重传次数」或者「最大超时时间」这两个的其中一个条件后，就会停止重传</strong>。</p><hr><p>最后说句，TCP 牛逼，啥异常都考虑到了。</p>',46),i=[r];function a(n,c){return t(),s("div",null,i)}const g=p(o,[["render",a],["__file","tcp_down_and_crash.html.vue"]]);export{g as default};
