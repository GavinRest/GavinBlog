import{_ as t,p as e,q as d,a1 as l}from"./framework-5866ffd3.js";const s="/assets/ospf_neighbor_topology-559c32a6.png",i="/assets/ospf_first_hello_R2-952fa55c.png",o="/assets/ospf_first_hello_R1-b46c7222.png",a="/assets/ospf_second_hello_R2-5d5efd1e.png",r="/assets/ospf_second_hello_R1-762e9635.png",n="/assets/ospf_neighbor_master_R2-1c74a9ff.png",c="/assets/ospf_neighbor_master_R1-1ac8c468.png",_={},h=l('<h1 id="ospf-邻居与邻接关系建立过程" tabindex="-1"><a class="header-anchor" href="#ospf-邻居与邻接关系建立过程" aria-hidden="true">#</a> ospf 邻居与邻接关系建立过程</h1><blockquote><p>本节主要介绍 ospf Neighbor &amp; Adjacency 建立过程 <a href="../../pcap/ospf_neighbor.pcapng">ospf_neighbor.pcapng</a></p></blockquote><h3 id="拓扑结构" tabindex="-1"><a class="header-anchor" href="#拓扑结构" aria-hidden="true">#</a> 拓扑结构</h3><hr><p>结构比较简单 2 台路由器 f0/0 口互联，配置 ospf 。</p><p><img src="'+s+'" alt="ospf_neighbor_topology"></p><h3 id="建立过程" tabindex="-1"><a class="header-anchor" href="#建立过程" aria-hidden="true">#</a> 建立过程</h3><hr><ol><li><p>INIT：R2 发送第一个 Hello包，R1收到第一个 Hello 包，并且双方收到这个 Hello 包中发现没有自己的 route-id（只有发起方route-id）。此时收到第一个包的路由器就进入INIT状态。（第一个Hello包只有 44 字节）</p><ul><li>R2 发送的第一个 hello 包 <img src="'+i+'" alt="ospf_first_hello"></li><li>R1 发送的第一个 hello 包 <img src="'+o+'" alt="ospf_first_hello_R1"></li></ul></li><li><p>2-Way：R2 发送第二个Hello包，R1收到第二个 Hello 包，发现有自己的 route-id（如果是 MA 网络选举 DR/BDR），然后进入 2-Way 状态，反之如此。当双方均进入 2-Way 状态说明已经建立邻居关系（第二个hello包48字节多了对端 Route-ID ）</p><ul><li>a. R2 发送第二个 hello 包 <img src="'+a+'" alt="ospf_second_hello_R2"></li><li>b. R1 发送第二个 hello 包 <img src="'+r+'" alt="ospf_second_hello_R1"></li></ul></li><li><p>Exstart：第一个 DBD 确认主从关系（route-id大为主），在此阶段检查 MTU，如果 MTU 不一致将卡在 Exstart 状态。DBD 传输中通过序列号隐式确认的方式保证可靠性。</p></li><li><p>Exchange ：通过后续的DBD交换LSA头部信息。</p><ul><li>a. 通过下面两个包可以看到R2的 Maser 置位为1，R1 为0。所以 R2 成为了Master <img src="'+n+'" alt="ospf_neighbor_master_R2"><img src="'+c+`" alt="ospf_neighbor_master_R1"></li><li>b. DBD 隐式确认 （通过下图表分析）</li></ul></li></ol><table><thead><tr><th></th><th>INIT</th><th>More</th><th>Master/Slave</th><th>Sequence</th><th>备注</th></tr></thead><tbody><tr><td>R2</td><td>1</td><td>1</td><td>1</td><td>8637</td><td>1-2个 DBD 包确立主从关系</td></tr><tr><td>R1</td><td>1</td><td>1</td><td>1</td><td>9663</td><td>1-2个 DBD 包确立主从关系</td></tr><tr><td>R2</td><td>1</td><td>1</td><td>1</td><td>8637</td><td>3个包已经确立R2为主</td></tr><tr><td>R1</td><td>0</td><td>1</td><td>0</td><td>8637</td><td>4个包用 seq 隐式确认</td></tr><tr><td>R2</td><td>0</td><td>0</td><td>1</td><td>8638</td><td>后续都通过 seq 隐式确认</td></tr><tr><td>R1</td><td>0</td><td>0</td><td>0</td><td>8638</td><td>后续都通过 seq 隐式确认</td></tr></tbody></table><ul><li>first dbd: first dbd 不携带LSA头部信息，通过first dbd确认主从关系。主的作用是为了控制序列号的同步，以保证可靠传输。Route-id大的为主。</li><li>普通 dbd: 只携带 LSA 头部信息，没有携带 LSA 的具体信息。承载完整 LSA 的是LSU包。</li><li>R1 和 R2 相互发送 LSR 、LSU 、LSACK。</li></ul><ol start="5"><li>Loading：DBD交换完成进入。</li><li>Full：完成邻接关系建立</li></ol><blockquote><p>hello 包主要内容</p></blockquote><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>1. 始发路由器 router-id
2. 始发路由器接口 area-id
3. 始发路由器接口的地址掩码
4. 始发路由器接口的 authentication type 和 authentication message
5. 始发路由器接口的 hello-interval
6. 始发路由器接口的 dead-interval
7. 路由器优先级
8. 指定 DR 和 BDR
9. 标识可选性能的5个标志位
10. 始发路由器的所有有效邻居的 router-id
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,14),p=[h];function u(f,b){return e(),d("div",null,p)}const R=t(_,[["render",u],["__file","ospf_neighbor.html.vue"]]);export{R as default};
