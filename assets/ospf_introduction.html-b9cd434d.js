import{_ as s,M as o,p as r,q as h,R as l,t as e,N as t,V as n,a1 as d}from"./framework-5866ffd3.js";const c={},p=l("h1",{id:"ospf-简介",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#ospf-简介","aria-hidden":"true"},"#"),e(" ospf 简介")],-1),_=d('<h3 id="ospf-基本原理" tabindex="-1"><a class="header-anchor" href="#ospf-基本原理" aria-hidden="true">#</a> OSPF 基本原理</h3><hr><ol><li><p>每一台路由器都会在所有形成邻接关系的邻居之间发送 LSA (链路状态通告)。</p></li><li><p>每一台收到从邻居路由器发出的 LSA 的路由器都会把这些 LSA 记录在它的 LSDB (链路状态数据库)中，并且拷贝一份 LSA 发送给所有邻居。</p></li><li><p>通过 LSA 泛洪扩散到整个区域（不同区域不泛洪），同 area 所有路由器都会形成相同 LSDB。</p></li><li><p>当路由器 LSDB 同步完毕，每台路由器都将以其自身为根，使用 SPF 算法计算无环拓扑图。以描述它所知道的到达每一个目的地的最短路径 (最小的路径代价)。 这个拓扑图就是 SPF 算法树。</p></li><li><p>每台路由器都将从 SPF 算法树中构建出自己的路由表。</p></li><li><p>当路由表构建完成，OSPF 协议就变成了一个 “安静” 的协议。邻居之间交换 Hello 包称为 keepalive ，默认每隔 30 分钟泛洪一次 LSA。</p></li></ol><h3 id="_5-种包类型与6-种邻居状态" tabindex="-1"><a class="header-anchor" href="#_5-种包类型与6-种邻居状态" aria-hidden="true">#</a> 5 种包类型与6 种邻居状态</h3><hr><ul><li><p>包类型</p><ol><li>Hello</li><li>DBD（Database description）</li><li>LSR（Link-State Request）</li><li>LSU（Link-State Update）</li><li>LS ACK（Link-State Acknowledgment）</li></ol></li><li><p>邻居状态</p><ol><li>INIT // 邻居发现阶段</li><li>2-Way // 邻居发现阶段</li><li>Exstart // 数据库同步阶段</li><li>Exchange // 数据库同步阶段</li><li>Loading // 数据库同步阶段</li><li>Full // LSDB同步完成建立邻接关系</li></ol></li></ul>',6),u={id:"邻居与邻接",tabindex:"-1"},S=l("a",{class:"header-anchor",href:"#邻居与邻接","aria-hidden":"true"},"#",-1),f=l("hr",null,null,-1),L=l("ul",null,[l("li",null,[l("p",null,"邻居关系：hello 包协商通过达到 2-way 状态")]),l("li",null,[l("p",null,"邻接关系：邻居 up，LSDB 同步完毕。达到 Full 状态")])],-1),k=l("h3",{id:"ospf-优点",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#ospf-优点","aria-hidden":"true"},"#"),e(" OSPF 优点")],-1),F=l("hr",null,null,-1),m=l("li",null,[l("p",null,"使用区域概念减小了路由协议对 CPU 和内存的消耗。")],-1),x=l("li",null,[l("p",null,"无类路由协议支持vlsm、cidr。")],-1),P=l("li",null,[l("p",null,"支持多链路等价负载均衡。")],-1),b=l("li",null,[l("p",null,"使用保留的组播地址来减小对不宣告0SPF的设备的影响。")],-1),B=l("li",null,[l("p",null,"支持认证。")],-1),A=l("li",null,[l("p",null,"使用可以跟踪外部路由的路由标记。")],-1),D={href:"https://tools.ietf.org/html/rfc2328",target:"_blank",rel:"noopener noreferrer"};function O(g,N){const i=o("RouterLink"),a=o("ExternalLinkIcon");return r(),h("div",null,[p,l("blockquote",null,[l("p",null,[e("OSPF：(Open Shortest Path First 开放式最短路径优先）OSPF是链路状态协议，使用 SPF ("),t(i,{to:"/nt/tcpip/layer3/ospf_dijkstra.html"},{default:n(()=>[e("dijkstra")]),_:1}),e(") 算法计算出路由域的拓扑结构图。")])]),_,l("h3",u,[S,e(),t(i,{to:"/nt/tcpip/layer3/ospf_neighbor.html"},{default:n(()=>[e("邻居与邻接")]),_:1})]),f,L,k,F,l("ol",null,[m,x,P,b,B,A,l("li",null,[l("p",null,[e("OSPF 支持具有 Tos 路由选择能力，但它从来没被广泛使用。基于该原因 "),l("a",D,[e("RFC2328"),t(a)]),e(" 删除了该 Tos 路由选择选项。")])])])])}const v=s(c,[["render",O],["__file","ospf_introduction.html.vue"]]);export{v as default};
